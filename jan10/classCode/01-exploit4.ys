# Attack 2: A malicious caller invokes a function
# that does not check how check the sizes of its
# arguments, this producing a vulnerability.

# Initialize the stack
	irmovq	0x2000, %rsp

main:
	# Let's start by calling innocent with a friendly input

	irmovq	gooddata, %rdi	# Place good data in the first parameter.
	call	innocent	# call function

	irmovq	baddata, %rdi	# Setup for call with baddata
	call	innocent	# call function

	halt		# If we return successfully, halt

# Attack 1: A benign caller invokes a function
# who is malicious; upon return the processor
# will be in an infinite loop.

# This is valid data that won't cause a problem
# in our example
.pos 0x500
gooddata:
	.quad	0xDEADC0DE
	.quad	0x15BADC0DE
	.quad	0

# This data is just too long and could cause
# undefined behavior, but isn't (designed to
# be) evil.
baddata:
	.quad	0xCAFEF00D
	.quad	0xi5SAD
	.quad	0xC0C0Ai5ACE
	.quad	0xC0FFEE
	.quad	0xDOEABEEF
	.quad	0

# This is going to be data that is downright
# malicious and triggers the infinite loop
# problem
evildata:
	.quad 0

# This function is responsible for copying the parameter passed
# to it from main into a local buffer. In real life, it might
# then use that local buffer to do other things; for now, we'll
# just do the copy and return which isn't all that useful.
# input %rdi: the address of a buffer we wish to copy
innocent:
	# This function needs space for a temporary buffer.
	# Such a buffer is a local variable that will be
	# allocated on the stack.

	# PART 1
	# Write the code to create space for a local buffer
	# that is 0x20 bytes large. Place the address of
	# that buffer in %rsi
	irmovq	0x20, %r10	
	subq	%r10, %rsp
	rrmovq	%rsp, %rsi	# rsi=address of local buffer

	# PART 3

innocentDone:
	# PART 2: Add code to teardown the stack frame

	ret

